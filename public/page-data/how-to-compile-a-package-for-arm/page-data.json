{"componentChunkName":"component---src-components-posts-post-template-index-jsx","path":"/how-to-compile-a-package-for-arm/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"how-to-compile-a-package-for-arm\" style=\"position:relative;\"><a href=\"#how-to-compile-a-package-for-arm\" aria-label=\"how to compile a package for arm permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to compile a package for ARM</h1>\n<p>In this blog post we will use Qemu multiarch on Docker to compile C source codes\nfor ARM processors.</p>\n<p>If you want to know how to run a ARM64 Debian on Docker skip to <a href=\"#qemu-multiarch\">Qemu multiarch</a></p>\n<h2 id=\"arm-architecture\" style=\"position:relative;\"><a href=\"#arm-architecture\" aria-label=\"arm architecture permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ARM architecture</h2>\n<p>ARM refers to a large group of CPU architectures designed for embedded systems\nand low cost computing. There are many variations of ARM instruction code and\nunfortunately they are not very compatible with each other.\nIt's important to identify the target architecture otherwise the built files\nmay not be compatible with the target machine.</p>\n<p>For this document I am going to compile for <code class=\"language-text\">arm64</code> (aka <code class=\"language-text\">aarch64</code> as GCC calls\nit). This architecture is used on <code class=\"language-text\">AWS</code> ARM instances which are available for\ncheaper price than the AMD64 ones.</p>\n<p>In a Debian machine running on an <code class=\"language-text\">aarch64</code> you can see:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ uname -a\nLinux hostname 4.9.0-12-arm64 #1 SMP Debian 4.9.210-1 (2020-01-20) aarch64 GNU/Linux</code></pre></div>\n<p>And:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ dpkg --print-architecture\narm64</code></pre></div>\n<p>As you can see <code class=\"language-text\">arm64</code> and <code class=\"language-text\">aarch64</code> are used almost interchangeably.</p>\n<p>There are two ways we can go about building, one is <code class=\"language-text\">cross compiling</code> using\n<code class=\"language-text\">aarch64-linux-gnu-gcc</code> which is GCC support for ARM64 architecture.</p>\n<p>The other (and less complicated) way is to make the package inside a VM. I will\nuse <code class=\"language-text\">Docker</code> with <code class=\"language-text\">qemu multiarch</code> which is basically a VM that allows running\nDocker images built for other architectures including <code class=\"language-text\">aarch64</code>.</p>\n<h2 id=\"building-using-docker\" style=\"position:relative;\"><a href=\"#building-using-docker\" aria-label=\"building using docker permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Building using Docker</h2>\n<p>The Docker image for <code class=\"language-text\">aarch64</code> is officially deprecated in favor of <a href=\"https://hub.docker.com/r/arm64v8/debian/\"><code class=\"language-text\">arch64v8</code></a>\nwhich has support for a broader variants of the architecture.</p>\n<h3 id=\"qemu-multiarch\" style=\"position:relative;\"><a href=\"#qemu-multiarch\" aria-label=\"qemu multiarch permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Qemu multiarch</h3>\n<p>First we will need to enable <a href=\"https://github.com/multiarch/qemu-user-static\"><code class=\"language-text\">qemu-user-static</code></a>\nwhich allows us to run the Docker image built for ARM.</p>\n<p><strong>Note:</strong> This setup uses <code class=\"language-text\">binfmt</code>, read more: <a href=\"https://en.wikipedia.org/wiki/Binfmt_misc\"><code class=\"language-text\">binfmt_misc</code></a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run --rm --privileged multiarch/qemu-user-static --reset -p yes</code></pre></div>\n<p>This will setup the multi arch files and now we can run Docker images that are\nbuilt for different architectures seamlessly.</p>\n<h3 id=\"debian-for-aarch64\" style=\"position:relative;\"><a href=\"#debian-for-aarch64\" aria-label=\"debian for aarch64 permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Debian for aarch64</h3>\n<p>After enabling mutliarch, we can simply run the debian image built for ARM:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -it arm64v8/debian:stretch\nroot@3b853bce5181:/#</code></pre></div>\n<p>Now we can see the architecture is shown to be ARM:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># uname -a\nLinux 3b853bce5181 5.3.0-46-generic #38-Ubuntu SMP Fri Mar 27 17:37:05 UTC 2020 aarch64 GNU/Linux</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># dpkg --print-architecture\narm64</code></pre></div>\n<p>That's it, we should now be able to download the source code and build it for\n<code class=\"language-text\">aarch64</code> inside that container.</p>\n<h3 id=\"downloading-and-building-ls\" style=\"position:relative;\"><a href=\"#downloading-and-building-ls\" aria-label=\"downloading and building ls permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Downloading and building ls</h3>\n<p>Just for the sake of the demonstration, let's write a simple hello world <code class=\"language-text\">C</code> and\ncompile it for ARM.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cat &lt;&lt;EOF &gt; helloworld.c\n#include &lt;stdio.h&gt;\nint main() {\n   printf(&quot;Hello, World!\\n&quot;);\n   return 0;\n}\nEOF</code></pre></div>\n<p>First we will need to install <code class=\"language-text\">gcc</code> to compile our source code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># apt update &amp;&amp; apt install gcc file -y</code></pre></div>\n<p>Then we can compile our source code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcc -o helloworld helloworld.c</code></pre></div>\n<p>And then run it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># ./helloworld\nHello, World!</code></pre></div>\n<p>We can also use the <code class=\"language-text\">file</code> command to tell us about the binary format of the\nexecutable we just built:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">helloworld: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV) ...</code></pre></div>\n<p>Yes, it's clearly built for ARM.</p>\n<p>One little trick we can do with GCC is that we can see the assembler code,\ntherefore we can see how the instruction set looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcc -o helloworld.asm -S helloworld.c</code></pre></div>\n<p>Contents of <code class=\"language-text\">helloworld.asm</code> will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\t.arch armv8-a\n\t.file\t&quot;helloworld.c&quot;\n\t.section\t.rodata\n\t.align\t3\n.LC0:\n\t.string\t&quot;Hello, World!&quot;\n\t.text\n\t.align\t2\n\t.global\tmain\n\t.type\tmain, %function\nmain:\n\tstp\tx29, x30, [sp, -16]!\n\tadd\tx29, sp, 0\n\tadrp\tx0, .LC0\n\tadd\tx0, x0, :lo12:.LC0\n\tbl\tputs\n\tmov\tw0, 0\n\tldp\tx29, x30, [sp], 16\n\tret\n\t.size\tmain, .-main\n\t.ident\t&quot;GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516&quot;\n\t.section\t.note.GNU-stack,&quot;&quot;,@progbits</code></pre></div>\n<h3 id=\"raspberry-pi\" style=\"position:relative;\"><a href=\"#raspberry-pi\" aria-label=\"raspberry pi permalink\" class=\"anchor-heading before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Raspberry Pi</h3>\n<p>This method can be used to build applications that run on other ARM processors.\nFor example on Raspberry Pi devices, instead of <code class=\"language-text\">aarch64</code> and <code class=\"language-text\">arm64</code>, you\nwould expect something similar to <code class=\"language-text\">armv7l</code> and <code class=\"language-text\">armhf</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ uname -a\nLinux raspberrypi 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l GNU/Linux</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ dpkg --print-architecture\narmhf</code></pre></div>","excerpt":"How to compile a package for ARM In this blog post we will use Qemu multiarch on Docker to compile C source codes\nfor ARM processors. If you…","fields":{"slug":"/how-to-compile-a-package-for-arm/"},"frontmatter":{"title":"How to compile a package for ARM","date":"04/28/2020","tags":["How-to"]}}},"pageContext":{"slug":"/how-to-compile-a-package-for-arm/"}}}